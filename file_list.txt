FNN
  file_list.txt:
FNN
  file_list.txt:

  go.mod:
module github.com/koushamad/POW-FNN

go 1.18

require github.com/gonum/matrix v0.0.0-20181209220409-c518dec07be9

require (
	github.com/gonum/blas v0.0.0-20181208220705-f22b278b28ac // indirect
	github.com/gonum/floats v0.0.0-20181209220543-c233463c7e82 // indirect
	github.com/gonum/internal v0.0.0-20181124074243-f884aa714029 // indirect
	github.com/gonum/lapack v0.0.0-20181123203213-e4cdc5a0bff9 // indirect
)

  go.sum:
github.com/gonum/blas v0.0.0-20181208220705-f22b278b28ac h1:Q0Jsdxl5jbxouNs1TQYt0gxesYMU4VXRbsTlgDloZ50=
github.com/gonum/blas v0.0.0-20181208220705-f22b278b28ac/go.mod h1:P32wAyui1PQ58Oce/KYkOqQv8cVw1zAapXOl+dRFGbc=
github.com/gonum/floats v0.0.0-20181209220543-c233463c7e82 h1:EvokxLQsaaQjcWVWSV38221VAK7qc2zhaO17bKys/18=
github.com/gonum/floats v0.0.0-20181209220543-c233463c7e82/go.mod h1:PxC8OnwL11+aosOB5+iEPoV3picfs8tUpkVd0pDo+Kg=
github.com/gonum/internal v0.0.0-20181124074243-f884aa714029 h1:8jtTdc+Nfj9AR+0soOeia9UZSvYBvETVHZrugUowJ7M=
github.com/gonum/internal v0.0.0-20181124074243-f884aa714029/go.mod h1:Pu4dmpkhSyOzRwuXkOgAvijx4o+4YMUJJo9OvPYMkks=
github.com/gonum/lapack v0.0.0-20181123203213-e4cdc5a0bff9 h1:7qnwS9+oeSiOIsiUMajT+0R7HR6hw5NegnKPmn/94oI=
github.com/gonum/lapack v0.0.0-20181123203213-e4cdc5a0bff9/go.mod h1:XA3DeT6rxh2EAE789SSiSJNqxPaC0aE9J8NTOI0Jo/A=
github.com/gonum/matrix v0.0.0-20181209220409-c518dec07be9 h1:V2IgdyerlBa/MxaEFRbV5juy/C3MGdj4ePi+g6ePIp4=
github.com/gonum/matrix v0.0.0-20181209220409-c518dec07be9/go.mod h1:0EXg4mc1CNP0HCqCz+K4ts155PXIlUywf0wqN+GfPZw=

  lib
    Layer.go:
package lib

import (
	"github.com/gonum/matrix/mat64"
)

type Layer struct {
	Weights *mat64.Dense
	Biases  *mat64.Dense
}

func NewLayer(inputSize, outputSize int) *Layer {
	return &Layer{
		Weights: mat64.NewDense(outputSize, inputSize, randomArray(outputSize*inputSize, -1, 1)),
		Biases:  mat64.NewDense(outputSize, 1, randomArray(outputSize, -1, 1)),
	}
}

func (l *Layer) Feedforward(input *mat64.Dense) *mat64.Dense {
	z := &mat64.Dense{}
	z.Mul(l.Weights, input.T())

	biasesT := &mat64.Dense{}
	biasesT.Clone(l.Biases.T())
	z.Add(z, biasesT)

	a := &mat64.Dense{}
	a.Apply(sigmoid, z)
	a.Clone(a.T())

	return a
}

func (l *Layer) UpdateWeights(input, delta *mat64.Dense, learningRate float64) {
	gradient := &mat64.Dense{}
	gradient.Mul(delta, input.T())
	gradient.Scale(learningRate, gradient)
	l.Weights.Add(l.Weights, gradient)

	l.Biases.Add(l.Biases, delta)
}

    NeuralNetwork.go:
package lib

import "github.com/gonum/matrix/mat64"

type NeuralNetwork struct {
	Layers []*Layer
}

func NewNeuralNetwork(inputSize int, layerSizes []int) *NeuralNetwork {
	nn := &NeuralNetwork{}
	prevSize := inputSize

	for _, size := range layerSizes {
		nn.Layers = append(nn.Layers, NewLayer(prevSize, size))
		prevSize = size
	}

	return nn
}

func (nn *NeuralNetwork) Train(X, Y *mat64.Dense, learningRate float64) {
	// Feedforward
	activations := nn.Feedforward(X)

	// Backpropagation
	errors := []*mat64.Dense{}
	delta := &mat64.Dense{}
	delta.Sub(Y.T(), activations[len(activations)-1])
	errors = append(errors, delta)

	for i := len(nn.Layers) - 1; i > 0; i-- {
		layer := nn.Layers[i]
		delta = &mat64.Dense{}
		delta.Mul(errors[0], layer.Weights.T())
		errors = append([]*mat64.Dense{delta}, errors...)
	}

	// Update weights
	for i, layer := range nn.Layers {
		layer.UpdateWeights(activations[i], errors[i], learningRate)
	}
}

func (nn *NeuralNetwork) Feedforward(X *mat64.Dense) []*mat64.Dense {
	activations := []*mat64.Dense{X}

	for _, layer := range nn.Layers {
		activations = append(activations, layer.Feedforward(activations[len(activations)-1]))
	}

	return activations
}

func (nn *NeuralNetwork) CalculateError(X, Y *mat64.Dense) float64 {
	activations := nn.Feedforward(X)
	predictions := activations[len(activations)-1]

	var error float64
	rows, _ := predictions.Dims()
	for i := 0; i < rows; i++ {
		error += 0.5 * (predictions.At(i, 0) - Y.At(i, 0)) * (predictions.At(i, 0) - Y.At(i, 0))
	}
	return error / float64(rows)
}

    POW.go:
package lib

import (
	"fmt"
	"github.com/gonum/matrix/mat64"
	"math"
	"math/rand"
	"time"
)

type InputData struct {
	X *mat64.Dense
	Y *mat64.Dense
}

func PoWFNN(data *InputData, targetError float64) {
	rand.Seed(time.Now().UnixNano())

	// Define the neural network
	nn := NewNeuralNetwork(2, []int{2, 1})

	// Train the neural network
	var error float64
	for {
		nn.Train(data.X, data.Y, 0.1)
		error = nn.CalculateError(data.X, data.Y)
		fmt.Printf("Error: %f\n", error)

		if error < targetError {
			break
		}
	}

	fmt.Println("PoW completed!")
}

func sigmoid(_, _ int, v float64) float64 {
	return 1.0 / (1.0 + math.Exp(-v))
}

func randomArray(size int, low, high float64) []float64 {
	arr := make([]float64, size)
	for i := range arr {
		arr[i] = rand.Float64()*(high-low) + low
	}
	return arr
}

  main.go:
package main

import (
	"github.com/gonum/matrix/mat64"
	"github.com/koushamad/POW-FNN/lib"
)

func main() {
	// Example input data
	data := &lib.InputData{
		X: mat64.NewDense(4, 2, []float64{0, 0, 0, 1, 1, 0, 1, 1}),
		Y: mat64.NewDense(4, 1, []float64{0, 1, 1, 0}),
	}

	// PoW with FNN
	targetError := 0.01
	lib.PoWFNN(data, targetError)
}

